<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><title>Hexo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">John Doe</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">12</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Hexo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Hexo</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/04/26/hello-world/">Hello World</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-26</time><div class="content"><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/28/库文件接口与二进制兼容/">库文件接口与二进制兼容</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-28</time><div class="content"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>YING’s <a href="https://izualzhy.cn/do-not-use-virtual-function-as-dynamic-lib-interface" target="_blank" rel="noopener">避免使用虚函数作为动态库的接口</a></p>
<p>陈硕’s <a href="https://blog.csdn.net/Solstice/article/details/6233478" target="_blank" rel="noopener">C++ 工程实践(4)：二进制兼容性</a></p>
<p>陈硕’s <a href="https://blog.csdn.net/Solstice/article/details/6244905" target="_blank" rel="noopener">C++ 工程实践(5)：避免使用虚函数作为库的接口</a></p>
<h2 id="感悟总结"><a href="#感悟总结" class="headerlink" title="感悟总结"></a>感悟总结</h2><p>​    陈硕在博客的最后推荐使用impl手法对库进行接口的暴露，虽然我之前的库一般也是使用impl手法进行封装，但最初的目的只是为了将不必要的代码对外隐藏，比如说private的成员变量和方法。在拜读两位大神的博客后，对<strong>二进制兼容性</strong>这个概念有了从编译原理层面的了解，同时加深了程序在运行期与编译期对动态库与静态库的处理过程。</p>
<pre><code>YING的博客以一个非常简单的DEMO证明：**以虚函数作为接口的动态库，若该库添加新的接口（旧接口不变），只通过替换动态库，而不用新的头文件对原APP的源码进行编译，会造成程序运行异常。**
</code></pre><p>​    以前我一直以为只要旧接口不变可以只替换动态库，看完上面的博客后，明白了两个概念，分别是<strong>bind-by-vtable-offset</strong>与<strong>bind-by-name</strong>。这两个概念在陈硕的博客最后的总结导出（主要是博主我基础知识薄弱），现摘抄如下</p>
<blockquote>
<p>为什么 non-virtual 函数比 virtual 函数更健壮？因为 virtual function 是 bind-by-vtable-offset，而 non-virtual function 是 bind-by-name。加载器 (loader) 会在程序启动时做决议(resolution)，通过 mangled name 把可执行文件和动态库链接到一起。</p>
</blockquote>
<p>通过<strong>bind-by-vtable-offset</strong>与<strong>bind-by-name</strong>也同时导出了<strong>二进制兼容性</strong>这个话题。</p>
<h3 id="application-binary-interface-ABI"><a href="#application-binary-interface-ABI" class="headerlink" title="application binary interface (ABI)"></a><strong>application binary interface</strong> (<strong>ABI</strong>)</h3><blockquote>
<p>In computer software, an <strong>application binary interface</strong> (<strong>ABI</strong>) is an <strong>interface</strong> between two binary program modules; often, one of these modules is a <strong>library</strong> facility, and the other is a program that is being run by a user.</p>
<p>An <strong>ABI</strong> defines how data structures or computational routines are accessed in <strong>machine code</strong>, which is a low-level, hardware-dependent format; </p>
<p>in contrast, an <strong>API</strong> defines this access in <strong>source code</strong>, which is a relatively high-level, relatively hardware-independent, often human-readable format.</p>
<p> A common aspect of an ABI is the calling convention, which determines how data is provided as input to or read as output from computational routines; </p>
</blockquote>
<p>在说ABI之前，我要先说说链接（link）.</p>
<p>   链接的本质就是把不同的object文件（目标文件）粘合到一个可执行文件，可以说有点像是搭积木或玩拼图。为了能使link成功，通常来说需要一套规则，而这个规则简单的说就是符号（Symbol）裁决，通常靠object文件中的Symbol Table来完成管理（这个规则是可以写一本书的量，我也不太懂）。那么什么是符号呢？在链接阶段，通常我们把函数和变量统称为符号（Symbol）。这是一个二元值，即（Symbol name， Symbol value），而这又分别对应到（函数名，函数地址）或者是（变量名，变量地址）。</p>
<p>   在20世纪70年代以前，编译器编译源代码产生目标文件时，符号名与相对应的函数名或者变量名是一样的。但是随着时间的推移，越来越多的库出现，这样的话符号相同的情况就越来越多，也就是符号冲突日益严重。为了防止符号名冲突，Unix下的C就规定，C语言源代码文件中的所有全局变量和函数名经过编译后，相对应的符号名前面加上下划线“_”。这种简单而原始的处理方法还是能应付小规模的开发的，但是大规模的团队如果命名不规范仍然会出现问题。</p>
<p>所以，像C++这样后来设计的语言，增加了namespace的方法来解决某块之前的符号冲突。</p>
<p>  C++除了namespace，还有override,overload,inherit,template….等等特性，这些都个符号管理增加了复杂度。C++的符号修饰的规则还和编译器相关，目前分成两个大派别，GCC和Virtual C++.有兴趣的请自己google.</p>
<p>  所以，大家知道了C和C++相互调用时候为什么会出现extern “C”{……..}了吧？extern “C”{……..}告诉编译器采用C的符号规则，这样大家都统一了！</p>
<p>   在说ABI之前仍然还要谈谈API.所谓API是指：Application Programming Interface。这是偏向源代码级别的接口，比如POSIX就是这样一个API标准。而ABI是指：Application Binary Interface。这是偏向二进制级别的接口，兼容程度比API更为严格。上面我们谈到的符号就是ABI中的一部分。除此之外还包含有C++对象的内存分布，函数调用方式，template如何实例化，异常的产生和捕获，内嵌函数的访问细节…..</p>
<p>   本来大家都希望ABI能统一的，这样的话，移植就可以轻松很多，然后不幸的是：仅符号管理我们就可以看出GNU和Microsoft就有很大的不同，而且即使是Microsoft的不同版本的编译器也可能有不一样的行为。所以C++一直被人诟病的原因之一，就是ABI的兼容性不好。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/28/glog源码笔记/">glog源码笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-28</time><div class="content"><p>异步信号安全</p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h3><p>​    RTTI（Run-Time Type Identification)，通过运行时类型信息程序能够使用基类的指针或引用来检查这些指针或引用所指的对象的实际派生类型。</p>
<h3 id="Name-Mangling概述"><a href="#Name-Mangling概述" class="headerlink" title="Name Mangling概述"></a>Name Mangling概述</h3><p>​    我们假设读者都有这样一个背景知识：“程序员写了一个叫functionName()的函数，该源程序编译为可执行程序后，这个程序的入口不在叫functionName(),而是一些看不懂的如abcde()的函数名”。Name Mangling就是编译过程中”functionName”变为“abcde”的过程，它的逆过程一般称为 demangling。</p>
<p>​    Name Mangling本身和glog没有什么关系，但是有时候我们在<strong>程序异常崩溃的时候希望通过堆栈信息查找程序异常的位置</strong>的时候，由于Name Mangling的原因，只能知道问题出在了“abcde”这个函数里，此时开发者就心里一万只草泥马了，我根本没有写过“abcde”这个函数啊，怎么会报错呢？<strong>那么在这波如此反人类的操作中，日志模块有必要实现demangling这个过程</strong>。下面引用一段网上摘抄关于Name Mangling的叙述：</p>
<blockquote>
<p>​    大型程序是通过多个模块构建而成，模块之间的关系由makefile来描述。对于由C++语言编制的大型程序而言，也是符合这个规则。<br>    程序的构建过程一般为：各个源文件分别编译，形成目标文件。多个目标文件通过链接器形成最终的可执行程序。显然，从某种程度上说，编译器的输出是链接器的输入，链接器要对编译器的输出做二次加工。<strong>从通信的角度看，这两个程序需要一定的协议来规范符号的组织格式。这就是Name Mangling产生的根本原因。</strong><br>    C++的语言特性比C丰富的多，C++支持的函数重载功能是需要Name Mangling技术的最直接的例子。对于重载的函数，不能仅依靠函数名称来区分不同的函数，因为C++中重载函数的区分是建立在以下规则上的：<br>函数名字不同 || 参数数量不同||某个参数的类型不同<br>那么区分函数的时候，应该充分考虑参数数量和参数类型这两种语义信息，这样才能为却分不同的函数保证充分性。<br>    当然，C++还有很多其他的地方需要Name Mangling，如namespace, class, template等等。<br>总的来说，<strong>Name Mangling就是一种规范编译器和链接器之间用于通信的符号表表示方法的协议，其目的在于按照程序的语言规范，使符号具备足够多的语义信息以保证链接过程准确无误的进行.</strong></p>
</blockquote>
<h3 id="如何识别C-编译以后的函数名（demangle）"><a href="#如何识别C-编译以后的函数名（demangle）" class="headerlink" title="如何识别C++编译以后的函数名（demangle）"></a>如何识别C++编译以后的函数名（demangle）</h3><blockquote>
<p>Transforming C++ ABI identifiers (like RTTI symbols) into the original C++ source identifiers is called “demangling.”</p>
</blockquote>
<p>C/C++语言在编译以后，函数的名字会被编译器修改，改成编译器内部的名字，这个名字会在链接的时候用到。如果用<a href="http://www.gnu.org/software/libc/manual/html_node/Backtraces.html" target="_blank" rel="noopener">backtrace</a>之类的函数打印堆栈时，显示的就是被编译器修改过的名字，比如说_Z3foov 。 那么这个函数真实的名字是什么呢？</p>
<p>每个编译器都有一套自己内部的名字，这里只是针对linux下g++而言。<br>以下是基本的方法:<br>每个方法都是以_Z开头，对于嵌套的名字（比如名字空间中的名字或者是类中间的名字,比如Class::Func）后面紧跟N ， 然后是各个名字空间和类的名字，每个名字前是名字字符的长度，再以E结尾。(如果不是嵌套名字则不需要以E结尾)</p>
<p>比如上面的_Z3foov 就是函数foo() , v 表示参数类型为void .<br>又如N:C:Func 经过修饰后就是 _ZN1N1C4FuncE, 这个函数名后面跟参数类型。 如果跟一个整型，那就是_ZN1N1C4FuncEi</p>
<p>另外在linux下有一个工具可以实现这种转换，这个工具是c++filt , 注意不是c++filter.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xuyang@ubuntu15:~/blog$ c++filt _ZN1N1C4FuncEi</span><br><span class="line">N::C::Func(int)</span><br></pre></td></tr></table></figure>
<h2 id="不可重入、线程安全与异步信号安全"><a href="#不可重入、线程安全与异步信号安全" class="headerlink" title="不可重入、线程安全与异步信号安全"></a>不可重入、线程安全与异步信号安全</h2><p><a href="http://www.cnblogs.com/zhaoyl/archive/2012/10/03/2711018.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhaoyl/archive/2012/10/03/2711018.html</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-reent.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-reent.html</a></p>
<h2 id="glog中的辅助调试手段"><a href="#glog中的辅助调试手段" class="headerlink" title="glog中的辅助调试手段"></a>glog中的辅助调试手段</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We don't use assert() since it's not guaranteed to be</span></span><br><span class="line"><span class="comment">// async-signal-safe.  Instead we define a minimal assertion</span></span><br><span class="line"><span class="comment">// macro. So far, we don't need pretty printing for __FILE__, etc.</span></span><br><span class="line"><span class="comment">/*in symbolize.cc*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The demangler is implemented to be used in async signal handlers to</span></span><br><span class="line"><span class="comment">// symbolize stack traces.  We cannot use libstdc++'s</span></span><br><span class="line"><span class="comment">// abi::__cxa_demangle() in such signal handlers since it's not async</span></span><br><span class="line"><span class="comment">// signal safe (it uses malloc() internally).</span></span><br><span class="line"><span class="comment">/*in demangle.h*/</span></span><br></pre></td></tr></table></figure>
<h2 id="glog中的宏"><a href="#glog中的宏" class="headerlink" title="glog中的宏"></a>glog中的宏</h2><h2 id="利用匿名对象"><a href="#利用匿名对象" class="headerlink" title="利用匿名对象"></a>利用匿名对象</h2><h2 id="glog在实时系统的改造"><a href="#glog在实时系统的改造" class="headerlink" title="glog在实时系统的改造"></a>glog在实时系统的改造</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/21/谈谈ROS与工业机器人/">谈谈ROS与工业机器人</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-21</time><div class="content"><h2 id="ROS算法与工具"><a href="#ROS算法与工具" class="headerlink" title="ROS算法与工具"></a>ROS算法与工具</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol>
<li><strong>rqt_plot</strong>：可以实时绘制当前任意Topic的数值曲线。</li>
<li><strong>rqt_graph</strong>：可以绘制出各节点之间的连接状态，和正在使用的Topic等。</li>
<li><strong>TF</strong>：TF是Transform的简写，利用它，我们可以实时知道各连杆坐标系的位姿，也可以求出两个坐标系的相对位置。</li>
<li><strong>Rviz</strong>：超强大的3D可视化工具，可以显示机器人模型、3D电影、各种文字图标、也可以很方便二次开发。</li>
</ol>
<h3 id="周边算法库"><a href="#周边算法库" class="headerlink" title="周边算法库:"></a>周边算法库:</h3><ol>
<li><strong>OROCOS</strong>：这个开源项目主要侧重于机器人底层控制器的设计，包括用于计算串联机械臂运动学数值解的KDL、贝叶斯滤波、实时控制等功能。</li>
<li><strong>OpenRave</strong>：这是在ROS之前最多人用来做运动规划的平台，ROS已经将其中的ikfast（计算串联机械臂运动学解析解）等功能吸收。</li>
<li><strong>Player</strong>：一款优秀的二维仿真平台，可以用于平面移动机器人的仿真，现在在ROS里可以直接使用。</li>
<li><strong>OpenCV</strong>：大名鼎鼎的机器视觉开源项目，ROS提供了cv_bridge，可以将OpenCV的图片与ROS的图片格式相互转换。</li>
<li><strong>OMPL</strong>：现在最著名的运动规划开源项目，已经成了MoveIt的一部分。</li>
<li><strong>Visp</strong>：一个开源视觉伺服项目，已经跟ROS完美整合。</li>
<li><strong>Gazebo</strong>：一款优秀的开源仿真平台，可以实现动力学仿真、传感器仿真等，也已被ROS吸收。</li>
</ol>
<h3 id="自主库算法库："><a href="#自主库算法库：" class="headerlink" title="自主库算法库："></a>自主库算法库：</h3><ol>
<li><strong>ORK</strong>：一个物体识别与位姿估计开源库，包含LineMod等算法，但实际使用效果还不是太理想。</li>
<li><strong>PCL</strong>：一个开源点云处理库，原本是从ROS中发展起来的，后来由于太受欢迎，为了让非ROS用户也能用，就单独立了一个PCL的项目。</li>
<li><strong>Gmapping</strong>：这其实是在OpenSlam项目继承过来的（后来发展和改动较大），利用gmapping可以实现laser-based SLAM，快速建立室内二维地图。</li>
<li><strong>Localization：</strong>基于扩展卡尔曼滤波（EKF）和无迹卡尔曼滤波（UKF）的机器人定位算法，可以融合各种传感器的定位信息，获得较为准确的定位效果。</li>
<li><strong>Navigation</strong>：基于Dijkstra、A*算法（全局规划器）和动态窗口法DWA（局部规划器）的移动机器人路径规划模块，可以在二维地图上实现机器人导航。</li>
<li><strong>MoveIt</strong>：这个是专注于移动机械臂运动规划的模块，下次讲运动规划入门的时候再详细介绍它。</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/21/谈谈Xenomaii与ADOES/">谈谈Xenomaii与ADEOS</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-21</time><div class="content"><p>ADEOS</p>
<p>实时性三部分</p>
<ol>
<li>用户态</li>
<li>内核态</li>
<li>定时器中断模式</li>
</ol>
<ol>
<li>单内核</li>
<li>微内核</li>
</ol>
<p>RTDM （Real Time Driver Model）</p>
<p>Xenomai 3 的两种形式</p>
<p>单核的 Mercury</p>
<p>双核的 Cobalt</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/21/Open-Source-EtherCAT-Master/">Open Source EtherCAT Master</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-21</time><div class="content"><p>##SOME</p>
<p><a href="http://openethercatsociety.github.io" target="_blank" rel="noopener">http://openethercatsociety.github.io</a></p>
<p>Supported by rt-labs and Speciaal Machinefabriek Ketels</p>
<ol>
<li><strong>SOEM</strong>：Simple Open EtherCAT Master</li>
<li><strong>SOES</strong>：Simple Open EtherCAT Slave</li>
</ol>
<p><strong>SOEM and SOES are small EtherCAT stacks for the embedded market.</strong></p>
<p>##IgH EtherCAT Master</p>
<p><a href="http://etherlab.org/en/ethercat/" target="_blank" rel="noopener">http://etherlab.org/en/ethercat/</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>（网上说的）使用起来SOEM的简单一些，而the IgH EtherCAT® Master更复杂一些，但对EtherCAT的实现更为完整。</li>
<li>好像 Igh 的只支持Linux平台，SOME支持Linux和Windows。</li>
<li>两者都需要实时内核的支持（如： Xenomai, RT-Preempt）</li>
<li>开发时需要注意，不仅对操作系统有要求，对CPU型号、网卡型号也有一定的要求。</li>
<li>为了保证实时性可能还需要修改网卡驱动代码。（网卡驱动可能自带缓冲）</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/21/五种开源协议的比较-BSD-Apache-GPL-LGPL-MIT/">五种开源协议的比较(BSD,Apache,GPL,LGPL,MIT)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-21</time><div class="content"><p>#五种开源协议的比较</p>
<p>该博文转载在网上。</p>
<h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p><strong>[original BSD license] 、[FreeBSD license] 、[Original BSD license]</strong></p>
<p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p>
<ol>
<li><p>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</p>
</li>
<li><p>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</p>
</li>
<li><p>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</p>
</li>
</ol>
<p>BSD 代码鼓励代码共享，但需要<strong>尊重代码作者的著作权</strong>。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对<strong>商业集成很友好</strong>的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>
<h2 id="Apache-Licence-2-0"><a href="#Apache-Licence-2-0" class="headerlink" title="Apache Licence 2.0"></a>Apache Licence 2.0</h2><p><strong>[Apache License, Version 2.0]、[Apache License, Version 1.1] 、[Apache License, Version 1.0]</strong></p>
<p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：</p>
<ol>
<li>需要给代码的用户一份Apache Licence</li>
<li>如果你修改了代码，需要在 被修改的文件中说明。</li>
<li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li>
<li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</li>
</ol>
<p>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</p>
<h2 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h2><p><strong>[GNU General Public License]</strong></p>
<p>​    我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p>
<p>​    GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。<strong>这就是所谓的”传染性 ”</strong> 。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。</p>
<p>​    由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</p>
<p>​    其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。</p>
<h2 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h2><p><strong>[GNU Lesser General Public License]</strong></p>
<p>​    LGPL是GPL的一个为主要为类库使用设计的开源协议。不同于GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议，<strong>LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码 </strong>。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>​    但是如果<strong>修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议</strong>。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<p>​    <strong>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品.</strong></p>
<h2 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h2><p><strong>[MIT]</strong></p>
<p>​    MIT是和BSD一样宽范的许可协议,<strong>作者只想保留版权,而无任何其他了限制</strong>.也就是说,你必须在你的发行版里包含原许可协议的声明 ,无论你是以二进制发布的还是以源代码发布的.</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/16/谈谈LinuxCNC/">谈谈LinuxCNC</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-16</time><div class="content"><h1 id="谈谈LinuxCNC"><a href="#谈谈LinuxCNC" class="headerlink" title="谈谈LinuxCNC"></a>谈谈LinuxCNC</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    在最开始打算摸索一下LinuxCNC是因为ROS一般用于科研，工业上较少使用，究其根本是因为其实时性与稳定性达不到工业标准。而LinuxCNC项目本身就是向工业方向发展，其可靠性与稳定性应该是没有问题的。故希望从LinuxCNC项目学习，主要包括保证系统实时性的方式、系统架构（整个控制系统中各个模块的解耦方式）、以及在线实时轨迹规划算法。在搜索资料发现，LinuxCNC项目原名<strong>EMC2</strong>，同时有另外一个分支叫<strong>Machinekit</strong>.</p>
<p>LinuxCNC项目官方网址：<a href="http://linuxcnc.org/" target="_blank" rel="noopener">http://linuxcnc.org/</a></p>
<p>Machinekit项目官方网址：<a href="http://www.machinekit.io" target="_blank" rel="noopener">http://www.machinekit.io</a></p>
<p>直到目前为止（2018年8月16日），LinuxCNC的官方稳定版本号为<strong>2.7.14</strong>，Machinekit没有明确的版本号，但从推荐的镜像介绍里面，使用的是基于3.8内核的Debian with xenomai kernel ，同时也表示，基于rt-preempt 4.x.x kerneled versions将会很快推出。</p>
<p>​    在这里先介绍一下Machinekit的背景，Machinekit项目最开始是希望在BeagleBoneBlack（俗称BBB，TI发布的一款嵌入式板，类似于树莓派，但是性能比树莓派稍弱，但是毕竟是TI出品，元器件与Layout都是工业级别的，稳定性有保证，相比之下，树莓派性能是比较强，但是貌似稳定性跟BBB不是一个级别，无法应用在工业领域）上移植LinuxCNC实现3D打印，无奈LinuxCNC项目最初使用的实时方案是RTAI，而RTAI不支持ARM平台，无奈之下Machinekit的作者只好自己移植其他的实时内核。所以总结起来就是 Machinekit更像是针对BBB这款硬件使用的移植版LinuxCNC。</p>
<h2 id="LinuxCNC与Machinekit的实时方案比较"><a href="#LinuxCNC与Machinekit的实时方案比较" class="headerlink" title="LinuxCNC与Machinekit的实时方案比较"></a>LinuxCNC与Machinekit的实时方案比较</h2><p>查阅两者官网可知，目前LinuxCNC项目支持的实时方案为</p>
<p>参考：<a href="http://linuxcnc.org/docs/2.7/html/getting-started/getting-linuxcnc.html" target="_blank" rel="noopener">http://linuxcnc.org/docs/2.7/html/getting-started/getting-linuxcnc.html</a></p>

<p>Machinekit项目支持的实时方案为：</p>
<p>参考：<a href="http://www.machinekit.io/docs/common/UnifiedBuild/" target="_blank" rel="noopener">http://www.machinekit.io/docs/common/UnifiedBuild/</a></p>
<blockquote>
<p>support for Xenomai and RT-PREEMPT realtime threads besides RTAI</p>
<p>There should be minimal user configuration changes for using the new RT options.</p>
<p>kernel autodetection</p>
<p>The ‘unified build’ branch will detect the RT features of the running kernel and choose an appropriate thread flavor.</p>
<p>runtime loading of support modules</p>
<p>All thread-specific code has been wrapped into shared objects and libraries which are loaded on demand. This enables fixes, upgrades or tests by just exchanging a file.</p>
</blockquote>
<p>总结一下就是</p>
<p>LinuxCNC支持Ubuntu 与Debian，实时方案选择Preempt-RT和RTAI</p>
<p>Machinekit对操作系统没有明确的限制，但是官方在Debian上测试没问题，相比之下，Machinekit支持Xenomai 、RT-PREEMPT实时方案。</p>
<p>对比LinuxCNC与Machinekit发现，Machinekit更致力于一套代码在多套平台上使用，其实现方式为抽象RTAPI层作为实时方案的抽象，在运行时动态加载对应的库文件。</p>
<p>个人感觉，Machinekit的格局比LinuxCNC要大，支持面更广。但又因为其通用性，可能在稳定性上比不上LinuxCNC，当然这只是个人推测，并没有实际测试。当然，假如只是为了学习，那么Machinekit应该更有意思。</p>
<h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p>大概浏览了一下LinuxCNC 与 Machinekit的开发文档，发现两者的整体架构非常一致（那当然啦，毕竟本是一家），而LinuxCNC 的文档看起来好像比Machinekit更加详细。下面就先以LinuxCNC 的软件架构进行分析，最后在对比Machinekit，看看Machinekit是如何在LinuxCNC的基础上做到多平台兼容的。</p>
<blockquote>
<p>在写这章之前 笔者希望先了解一下xenomai的使用方式，故该博文先暂停。</p>
</blockquote>
<h2 id="软PLC-Classic-Ladder"><a href="#软PLC-Classic-Ladder" class="headerlink" title="软PLC Classic Ladder"></a>软PLC Classic Ladder</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/15/Linux操作系统实时性分析/">Linux操操作系统实时性分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-15</time><div class="content"><h1 id="Linux操操作系统实时性分析"><a href="#Linux操操作系统实时性分析" class="headerlink" title="Linux操操作系统实时性分析"></a>Linux操操作系统实时性分析</h1><h2 id="博主总结"><a href="#博主总结" class="headerlink" title="博主总结"></a>博主总结</h2><p>本文摘录自 <a href="https://blog.csdn.net/lu_embedded/article/details/53572620" target="_blank" rel="noopener">https://blog.csdn.net/lu_embedded/article/details/53572620</a></p>
<p>​    该文章是博主在摸索实时Linux实现方案时搜索到的，在知网上关于标准Linux实时性的分析与原博文相差无几，故直接摘录。在进一步深入摸索中，希望对比 RT-Preempt与Xenomai两种实时方案有何异同时找到该文章，对这两种实时改造方案进行了分析。</p>
<p>​    总结如下：</p>
<ul>
<li><p>RT-Preempt属于直接修改标准linux内核的源码，使得内核可抢占，达到实时要求。</p>
</li>
<li><p>Xenomai属于双内核实现方式，在标准内核以外构建另外一个实时内核，将标准内核作为实时内核中的一个进程来运行。</p>
</li>
<li><p>在开发流程上，RT-Preempt提供POSIX标准接口，与一般linux程序开发无异；Xenomai除了提供POSIX接口以外，还提供其他一些商用实时系统兼容的接口，方便用户移植代码。</p>
</li>
<li><p>在上述两种实时方案中进行选择时，官方给出的答案如下：</p>
<p>Xenomai 3 FAQ</p>
<p><strong>Q</strong>: I can run POSIX based applications directly over a PREEMPT_RT kernel on my target system, so what is the point of running Xenomai 3 there?</p>
<p><strong>A</strong>: If your application is already fully POSIXish, and the performances requirements are met, then there is likely no point. However, you may want to consider Xenomai 3 in two other situations:</p>
<ul>
<li>you want to port a legacy embedded application to Linux without having to switch APIs, i.e. you don’t want to rewrite it on top of the POSIX interface. Xenomai may help in this case, since it supports multiple programming interfaces over a common real-time layer, including emulators of traditional RTOS APIs. Xenomai 3 will make those APIs available to a PREEMPT_RT based system as well.</li>
</ul>
</li>
</ul>
<ul>
<li><p>the target hardware platform has limited horsepower, and/or you want the real-time job to put the smallest possible overhead on your system. This is where dual kernels are usually better than a native preemption system. With the latter, all parts of the Linux system have to run internal code that prevents real-time activities from being delayed in an unacceptable manner (e.g. priority inheritance mechanism, threaded IRQ handlers). In a dual kernel system, there is no need for this, since the real-time co-kernel runs separately from the normal Linux kernel. Therefore, regular Linux activity is not charged for real-time activity, it does not even have to know about it.</p>
<p>​</p>
<p>In short, there cannot be any pre-canned answer to such a question: it really depends on your performance requirements, and your target hardware capabilities. This has to be evaluated on a case-by-case basis. Telling the world about “we can achieve X microseconds worst-case latency” without specifying the characteristics of the target platform would make no sense. </p>
<p>​</p>
</li>
</ul>
<h2 id="制约标准Linux实时性的因素"><a href="#制约标准Linux实时性的因素" class="headerlink" title="制约标准Linux实时性的因素"></a>制约标准Linux实时性的因素</h2><p>​    虽然Linux系统功能强大、实用性强、易于软件的二次开发，并且提供编程人员熟悉的标准API。但是由于Linux系统一开始就被设计成GPOS（通用操作系统），它的目的是构建一个完整、稳定的开源操作系统，尽量缩短系统的平均响应时间，提高吞吐量，注重操作系统的整体功能需求，达到更好地平均性能。（在操作系统中，我们可以把吞吐量简单的理解为在单位时间内系统能够处理的事件总数。）<br>　　因此在设计Linux的进程调度算法时主要考虑的是公平性，也就是说，调度器尽可能将可用的资源平均分配给所有需要处理器的进程，并保证每个进程都得以运行。但这个设计目标是和实时进程的需求背道而驰的，所以<strong>标准Linux并不提供强实时性</strong>。<br>　　Linux系统实时性不强使其在嵌入式应用中有一定的局限性，主要是受内核可抢占性、进程调度方式、中断处理机制、时钟粒度等几个方面的制约，具体如下：</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>​    Linux系统提供符合POSIX标准的调度策略，包括FIFO调度策略（<code>SCHED_FIFO</code>）、带时间片轮转的实时调度策略（<code>SCHED_RR</code>）和静态优先级抢占式调度策略（<code>SCHED_OTHER</code>）。Linux进程默认的调度策略为<code>SCHED_OTHER</code>，这种调度方式虽然可以让进程公平地使用CPU和其它资源，但是并不能保证对时间要求严格或者高优先级的进程将先于低优先级的执行，这将严重影响系统实时性。那么，将实时进程的调度策略设置为<code>SCHED_FIFO</code> 或<code>SCHED_RR</code> ，似乎使得Linux系统具备根据进程优先级进行实时调度的能力，但问题在于，Linux系统在用户态支持可抢占调度策略，而在内核态却不完全支持抢占式调度策略。这样运行在Linux内核态的任务（包括系统调用和中断处理）是不能被其它优先级更高的任务所抢占的，由此引起优先级逆转问题。</p>
<h3 id="内核抢占机制"><a href="#内核抢占机制" class="headerlink" title="内核抢占机制"></a>内核抢占机制</h3><p>​    Linux的系统进程运行分为用户态和内核态两种模式。当进程运行在用户态时，具有高的优先级的进程可以抢占进程，可以较好地完成任务；但是当进程运行在内核态时，即使其他高优先级进程也不能抢占该进程。当进程通过系统调用进入内核态运行时，实时任务必须等待系统调用返回后才能获得系统资源。这和实时系统所要求的高优先级任务运行是相互矛盾的。<br>　　当然，这种情况在Linux2.6版本的内核发布以来有了显著改进，<strong>Linux2.6版本后的内核是抢占式的，这意味着进程无论在处于内核态还是用户态，都可能被抢占</strong>。Linux2.6以后的内核提供以下3种抢占模式供用户选择。<br>　　<code>PREEMPT_NONE</code>——没有强制性的抢占。整体的平均延时较低，但偶尔也会出现一些较长的延时。它最适合那些以整体吞吐率为首要设计准则的应用。<br>　　<code>PREEMPT_VOLUNTARY</code>——降低延时的第一阶段。它会在内核代码的一些关键位置上放置额外的显示抢占点，以降低延时。但这是以牺牲整体吞吐率为代价的。<br>　　<code>PREEMPT/PREEMPT_DESKTOP</code>——这种模式使内核在任何地方都是可抢占的，临界区除外。这种模式适用于那些需要软实时性能的应用程序，比如音频和多媒体。这也是以牺牲整体吞吐率为代价的。</p>
<h3 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h3><p>Linux在进行中断处理时都会关闭中断，这样可以更快、更安全地完成自己的任务，但是在此期间，即使有更高优先级的实时进程发生中断，系统也无法响应，必须等到当前中断任务处理完毕。这种状况下会导致中断延时和调度延时增大，降低Linux系统的实时性。</p>
<h3 id="时钟粒度粗糙"><a href="#时钟粒度粗糙" class="headerlink" title="时钟粒度粗糙"></a>时钟粒度粗糙</h3><p>​    时钟系统是计算机的重要组成部分，相当于整个操作系统的脉搏。系统所能提供的最小时间间隔称为时钟粒度，时钟粒度与进程响应的延迟性是正比关系，即粒度越粗糙，延迟性越长。但时钟粒度并不是越小越好，就同等硬件环境而言，较小的时间粒度会导致系统开销增大，降低整体吞吐率。在Linux2.6内核中，时钟中断发生频率范围是50~1200Hz，周期不小于0.8ms，对于需要几十微秒的响应精度的应用来说显然不满足要求。而在嵌入式Linux系统中，为了提高整体吞吐率，时钟频率一般设置为100HZ或250HZ。<br>　　另外，系统时钟负责软定时，当软定时器逐渐增多时会引起定时器冲突，增加系统负荷。</p>
<h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><p>​    Linux采用虚拟内存技术，进程可以运行在比实际空间大得多的虚拟空间中。在分时系统中，虚拟内存机制非常适用，然而对于实时系统这是难以忍受的，频繁的页面换进换出会使得系统进程运行无法在规定时间内完成。<br>　　对于此问题，Linux系统提供内存锁定功能，以避免在实时处理中存储页被换出。</p>
<h3 id="共享资源的互斥访问差异"><a href="#共享资源的互斥访问差异" class="headerlink" title="共享资源的互斥访问差异"></a>共享资源的互斥访问差异</h3><p>​    多个任务互斥地访问同一共享资源时，需要防止数据遭到破坏，系统通常采用信号量机制解决互斥问题。然而，在采取基于优先级调度的实时系统中，信号量机制容易造成优先级倒置，即低优先级任务占用高优先级任务资源，导致高优先级任务无法运行。</p>
<p>　　虽然从2.6.12版本之后，Linux内核已经可以在较快的x86处理器上实现10毫秒以内的软实时性能。但<strong>如果想实现可预测、可重复的微秒级的延时，使Linux系统更好地应用于嵌入式实时环境，则需要在保证Linux系统功能的基础上对其进行改造</strong>。下一节将介绍通过实时补丁来提高Linux实时性的方法。</p>
<h2 id="常用的实时Linux改造方案"><a href="#常用的实时Linux改造方案" class="headerlink" title="常用的实时Linux改造方案"></a>常用的实时Linux改造方案</h2><p>　根据实时性系统要求以及Linux的特点和性能分析，对标准Linux实时性的改造存在多种方法，较为合理的两大类方法为：</p>
<ol>
<li>直接修改Linux内核源代码。</li>
<li>双内核法。</li>
</ol>
<h3 id="直接修改Linux内核源代码"><a href="#直接修改Linux内核源代码" class="headerlink" title="直接修改Linux内核源代码"></a>直接修改Linux内核源代码</h3><p>​    对Linux内核代码进行细微修改并不对内核作大规模的变动，在遵循GPL协议的情况下，直接修改内核源代码将Linux改造成一个完全可抢占的实时系统。核心修改面向局部，不会从根本上改变Linux内核，并且一些改动还可以通过Linux的模块加载来完成，即系统需要处理实时任务时加载该功能模块，不需要时动态卸载该模块。<br>　　目前kernel.org发布的主线内核版本还不支持硬实时。为了开启硬实时的功能，必须对代码打补丁。实时内核补丁是多方努力的共同成果，目的是为了降低Linux内核的延时。这个补丁有多位代码贡献者，目前由Ingo Molnar维护，补丁网址如下：<a href="http://www.kernel.org/pub/linux/kernel/projects/rt/。" target="_blank" rel="noopener">www.kernel.org/pub/linux/kernel/projects/rt/。</a><br>　　在配置已经打过实时补丁的内核代码时，我们发现实时补丁添加了第4种抢占模式，称为<code>PREEMPT_RT</code>（实时抢占）。实时补丁在Linux内核中添加了几个重要特性，包括使用可抢占的互斥量来替代自旋锁；除了使用<code>preempt_disable()</code>保护的区域以外，内核中的所有地方都开启了非自愿式抢占（involuntary preemption）功能。这种模式能够显著降低抖动（延时的变化），并且使那些对延时要求很高的实时应用具有可预测的较低延时。<br>　　这种方法存在的问题是：很难百分之百保证，在任何情况下，GPOS程序代码绝不会阻碍RTOS的实时行为。也就是说，通过修改Linux内核，难以保证实时进程的执行不会遭到非实时进程所进行的不可预测活动的干扰。</p>
<h3 id="双内核法"><a href="#双内核法" class="headerlink" title="双内核法"></a>双内核法</h3><p>实际上，双内核的设计缘由在于，人们不相信标准Linux内核可以在任何情况下兑现它的实时承诺，因为GPOS内核本身就很复杂，更多的程序代码通常会导致更多的不确定性，这样将无法符合可预测性的要求。更何况Linux内核极快的发展速度，使其会在很短的时间内带来很大的变化，直接修改Linux内核源代码的方法将难以保持同步。<br>　　双内核法是在同一硬件平台上采用两个相互配合，共同工作的系统核心，通过在Linux系统的最底层增加一层实时核心来实现。其中的一个核心提供精确的实时多任务处理，另一个核心提供复杂的非实时通用功能。<br>　　双内核方法的实质是把标准的Linux内核作为一个普通进程在另一个内核上运行。关键的改造部分是在Linux和中断控制器之间加一个中断控制的仿真层，成为其实时内核的一部分。该中断仿真机制提供了一个标志用来记录Linux的关开中断情况。一般只在修改核心数据结构关键代码时才关中断，所以其中断响应很小。其优点是可以做到硬实时，并且能很方便地实现一种新的调度策略。<br>　　为方便使用，实时内核通常由一套可动态载入的模块提供，也可以像编译任何一般的子系统那样在Linux源码树中直接编译。<strong>常用的双内核法实时补丁有RTLinux/GPL、RTAI 和 Xenomai</strong>，其中RTLinux/GPL只允许以内核模块的形式提供实时应用；而RTAI和Xenomai支持在具有MMU保护的用户空间中执行实时程序。下面，我们将对RTAI与Xenomai进行分析。</p>

<p>​    图1所示为RTAI和Xenomai两个实时内核分别与标准Linux内核组成双内核系统是的分层结构。可以看到两者有稍微不同的组织形式，与Xenomai让ADEOS掌控所有的中断源不同的是，RTAI拦截它们，使用ADEOS将那些RTAI不感兴趣的中断通知送给Linux（也就是，中断不影响实时时序）。这样混合过程的目的是提高性能，因为在这种情况下，如果中断是要唤醒一个实时任务，就避免了由ADEOS管理中断的开销。从这里可以看出，RTAI的实时性能应该是比Xenomai要好的。<br>　　RTAI（Real-Time Linux Application interface）虽然实时性能较好，但对ARM支持不够，更新速度极慢，造成项目开发周期长，研发成本高。<br>　　与RTAI相比，Xenomai更加专注于用户态下的实时性、提供多套与主流商业RTOS兼容的API以及对硬件的广泛支持，在其之上构建的应用系统能保持较高实时性，而且稳定性和兼容性更好；此外，Xenomai社区活跃，紧跟主流内核更新，支持多种架构，对ARM的支持很好。<br>　　Xenomai是Linux内核的一个实时开发框架。它希望无缝地集成到Linux环境中来给用户空间应用程序提供全面的、与接口无关的硬实时性能。Xenomai是基于一个抽象实时操作系统核心的，可以被用来在一个通用实时操作系统调用的核心上，构建任意多个不同的实时接口。Xenomai项目始于2001年8月。2003年它和RTAI项目合并推出了RTAI/fusion。2005年，因为开发理念不同，RTAI/fusion项目又从RTAI中独立出来作为Xenomai项目。相比之下，<strong>RTAI项目致力于技术上可行的最低延迟</strong>；<strong>Xenomai除此之外还很着重扩展性、可移植性以及可维护性</strong>。Xenomai项目将对Ingo Molnar的<code>PREEMPT_PT</code>实时抢占补丁提供支持，这又是与RTAI项目的一个显著的不同。RTAI和Xenomai都有开发者社区支持，都可以作为一个VxWorks的开源替代。<br>　　Xenomai是基于Adeos（Adaptive Domain Environment for Operating System）实现的，Adeos的目标是为操作系统提供了一个灵活的、可扩展的自适应环境；在这个环境下，多个相同或不同的操作系统可以共存，共享硬件资源。基于Adeos的系统中，每个操作系统都在独立的域内运行，每个域可以有独立的地址空间和类似于进程、虚拟内存等的软件抽象层，而且这些资源也可以由不同的域共享。与以往传统的操作系统共存方法不同，Adeos是在已有的操作系统下插入一个软件层，通过向上层多个操作系统提供某些原语和机制实现硬件共享。应用上主要是提供了一个用于“硬件-内核”接口的纳内核（超微内核），使基于Linux环境的系统能满足硬实时的要求。<br>　　Xenomai正是充分利用了Adeos技术，它的首要目标是帮助人们尽量平缓地移植那些依赖传统RTOS的应用程序到GNU/Linux环境，避免全部重写应用程序。它提供一个模拟器模拟传统实时操作系统的API，这样就很容易移植应用程序到GNU/Linux环境中，同时又能保持很好的实时性。Xenomai的核心技术就是使用一个实时微内核来构建这些实时API，也称作“Skin”。Xenomai通过这种接口变种技术实现了针对多种传统RTOS的应用编程接口，方便传统RTOS应用程序向GNU/Linux的移植。图2描述了Xenomai的这种带Skin的分层架构。</p>

<p>​    从图2可以看出，Xenomai系统包含多个抽象层：Adeos纳内核直接工作在硬件之上；位于Adeos之上的是与处理器体系结构相关的硬件抽象层（Hardware Abstraction Layer, HAL）；系统的中心部分是运行在硬件抽象层之上的抽象的实时内核，实时内核实现了一系列通用RTOS的基本服务。这些基本服务可以由Xenomai的本地API（Native）或由建立在实时内核上的针对其他传统RTOS的客户API提供，如RTAI、POSIX、VxWorks、uITRON、pSOS+等。客户API旨在兼容其所支持的传统RTOS的应用程序在Xenomai上的移植，使应用程序在向Xenomai/Linux体系移植的过程中不需要完全重新改写，此特性保证了Xenomai系统的稳健性。Xenomai/Linux系统为用户程序提供了用户空间和内核空间两种模式，前者通过系统调用接口实现，后者通过实时内核实现。用户空间的执行模式保证了系统的可靠性和良好的软实时性，内核空间程序则能提供优秀的硬实时性。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/08/15/Linux-with-PREEMPT-RT/">Linux with PREEMPT_RT</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-15</time><div class="content"><h1 id="Linux-with-PREEMPT-RT"><a href="#Linux-with-PREEMPT-RT" class="headerlink" title="Linux with PREEMPT_RT"></a>Linux with PREEMPT_RT</h1><h2 id="博主总结"><a href="#博主总结" class="headerlink" title="博主总结"></a>博主总结</h2><p>文章摘录自 <a href="https://wiki.linuxfoundation.org/realtime/documentation/start" target="_blank" rel="noopener">https://wiki.linuxfoundation.org/realtime/documentation/start</a> 更多内容请前往该网址查看</p>
<p>本博文介绍了如何在标准的Linux系统上<strong>打 PREEMPT_RT 补丁</strong>使之具备实时性，其实就是教你怎么编译内核。</p>
<p>除了介绍如何打补丁外，讲述了如何建立一个基础的<strong>实时线程</strong>，并介绍了实时线程在内存方面的注意事项，包括</p>
<ol>
<li><p>锁内存</p>
</li>
<li><p>栈内存</p>
</li>
<li><p>动态内存分配</p>
<p>​</p>
<p>最后给出了在实时线程的基础上给出了<strong>周期任务在实时线程中的实现方式</strong>例子。</p>
</li>
</ol>
<h2 id="setup-Linux-with-PREEMPT-RT-properly"><a href="#setup-Linux-with-PREEMPT-RT-properly" class="headerlink" title="setup Linux with PREEMPT_RT properly"></a>setup Linux with PREEMPT_RT properly</h2><p>​    Linux in itself is not real time capable. With the additional PREEMPT_RT patch it gains real-time capabilities. The sources have to be downloaded first. After unpacking and patching, the kernel configuration has to be adapted. Then, the kernel can be built and started.</p>
<h3 id="Getting-the-sources"><a href="#Getting-the-sources" class="headerlink" title="Getting the sources"></a>Getting the sources</h3><p>​    First, the kernel version should be chosen. After this, take a look if the PREEMPT_RT patch is <a href="https://www.kernel.org/pub/linux/kernel/projects/rt" target="_blank" rel="noopener">available</a> for this particular version.</p>
<p>​    The source of the desired version has to be downloaded (for the Linux kernel as well as for the PREEMPT_RT patch). This example is based on the Linux kernel version 4.4.12.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.4.12.tar.xz</span><br><span class="line">$ wget https://www.kernel.org/pub/linux/kernel/projects/rt/4.4/patch-4.4.12-rt19.patch.xz</span><br></pre></td></tr></table></figure>
<p>After downloading, unpack the archives and patch the Linux kernel:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ xz -<span class="built_in">cd</span> linux-4.4.12.tar.xz | tar xvf -</span><br><span class="line">$ <span class="built_in">cd</span> linux-4.4.12</span><br><span class="line">$ xzcat ../patch-4.4.12-rt19.patch.xz | patch -p1</span><br></pre></td></tr></table></figure>
<h3 id="Configuring-the-kernel"><a href="#Configuring-the-kernel" class="headerlink" title="Configuring the kernel"></a>Configuring the kernel</h3><p>The only necessary configuration for real-time Linux kernel is the choice of the “Fully Preemptible Kernel” preemption model (CONFIG_PREEMPT_RT_FULL). All other kernel configuration parameters depend on system requirements. For detailed information about how to configure a kernel have a look at <a href="https://www.kernel.org/doc/Documentation/kbuild/kconfig.txt" target="_blank" rel="noopener">Linux kernel documentation</a>.</p>
<p>​    When measuring system latency all kernel debug options should be turned off. They require much overhead and distort the measurement result. Examples for those debug mechanism are:</p>
<ul>
<li><p>DEBUG_PREEMPT</p>
</li>
<li><p>Lock Debugging (spinlocks, mutexes, etc. . . )</p>
</li>
<li><p>DEBUG_OBJECTS</p>
</li>
<li><p>…</p>
<p>Some of those debugging mechanisms (like lock debugging) produce a randomized overhead in a range of some micro seconds to several milliseconds depending on the kernel configuration as well as on the compile options (DEBUG_PREEMPT has a low overhead compared to Lock Debugging or DEBUG_OBJECTS).</p>
<p>However, in the first run of a real-time capable Linux kernel it might be advisable to use those debugging mechanisms. This helps to locate fundamental problems.</p>
</li>
</ul>
<h3 id="Building-the-kernel"><a href="#Building-the-kernel" class="headerlink" title="Building the kernel"></a>Building the kernel</h3><p>​    Building the kernel and starting the kernel works similarly to a kernel without PREEMPT_RT patch.</p>
<h2 id="Build-a-simple-RT-application"><a href="#Build-a-simple-RT-application" class="headerlink" title="Build a simple RT application"></a>Build a simple RT application</h2><p>​    The POSIX API forms the basis of real-time applications running under PREEMPT_RT. For the real-time thread a POSIX thread is used (pthread). Every real-time application needs proper handling in several basic areas like scheduling, priority, memory locking and stack prefaulting.</p>
<h3 id="Basic-prerequisites"><a href="#Basic-prerequisites" class="headerlink" title="Basic prerequisites"></a>Basic prerequisites</h3><p>​    Three basic prerequisites are introduced in the next subsections, followed by a short example illustrating those aspects.</p>
<h4 id="Scheduling-and-priority"><a href="#Scheduling-and-priority" class="headerlink" title="Scheduling and priority"></a>Scheduling and priority</h4><p>​    The <a href="https://wiki.linuxfoundation.org/realtime/documentation/technical_basics/sched_policy_prio/start" target="_blank" rel="noopener">scheduling policy</a> as well as the priority must be set by the application explicitly. There are two possibilities for this:</p>
<ol>
<li><p><strong>Using sched_setscheduler()</strong></p>
<p>This funcion needs to be called in the start routine of the pthread before calculating RT specific stuff.</p>
</li>
<li><p><strong>Using pthread attributes</strong> </p>
<p>The functions <code>pthread_attr_setschedpolicy()</code> and <code>pthread_attr_setschedparam()</code>offer the interfaces to set policy and priority. Furthermore scheduler inheritance needs to be set properly to PTHREAD_EXPLICIT_SCHED by using <code>pthread_attr_setinheritsched()</code>. This forces the new thread to use the policy and priority specified by the pthread attributes and not to use the inherit scheduling of the thread which created the real-time thread.</p>
</li>
</ol>
<h3 id="Memory-for-Real-time-Applications"><a href="#Memory-for-Real-time-Applications" class="headerlink" title="Memory for Real-time Applications"></a>Memory for Real-time Applications</h3><p>​    Proper handling of memory will improve a real-time application’s deterministic behavior. Three areas of memory management within the purview of a real-time application are considered :</p>
<ol>
<li><strong>Memory Locking</strong></li>
<li><strong>Stack Memory for RT threads</strong></li>
<li><strong>Dynamic memory allocation</strong></li>
</ol>
<p>Keep in mind that the <a href="https://wiki.linuxfoundation.org/realtime/documentation/howto/applications/application_base" target="_blank" rel="noopener">usual sequence</a> is for an application to begin its execution as a regular (non-RT) application, then create the RT threads with appropriate resources and scheduling parameters.</p>
<h4 id="Memory-Locking"><a href="#Memory-Locking" class="headerlink" title="Memory Locking"></a>Memory Locking</h4><p>Memory locking APIs allow an application to instruct the kernel to associate (some or all of its) virtual memory pages with real page frames and keep it that way. In other words :</p>
<ul>
<li><p>Memory locking APIs will trigger the necessary page-faults, to bring in the pages being locked, to physical memory. Consequently first access to a locked-memory (following an <code>mlock*()</code> call) will already have physical memory assigned and will not page fault (in RT-critical path). This removes the need to explicitly pre-fault these memory.</p>
</li>
<li><p>Further memory locking prevents an application’s memory pages, from being paged-out, anytime during its lifetime even in when the overall system is facing memory pressure.</p>
</li>
</ul>
<p>Applications can either use <code>mlock(…)</code> or <code>mlockall(…)</code> for memory locking. Specifics of these C Library calls can be found here <a href="http://www.gnu.org/software/libc/manual/html_node/Locking-Pages.html" target="_blank" rel="noopener">The GNU C Library: Locking pages</a>. Note that these calls requires the application to have sufficient privileges (i.e. <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">CAP_IPC_LOCK capability</a>) to succeed.</p>
<p>While <code>mlock(&lt;addr&gt;, &lt;length&gt;)</code> locks specific pages (described by <em>address</em> and <em>length</em>), <code>mlockall(…)</code> locks an application’s entire virtual address space (i.e <a href="https://wiki.linuxfoundation.org/realtime/documentation/howto/applications/memory/mlockall_globals_sample" target="_blank" rel="noopener">globals</a>, stack, heap, code) in physical memory. The trade-off between convenience and locking-up excess RAM should drive the choice of one over the other. Locking only those areas which are accessed by RT-threads (using <code>mlock(…)</code>) could be cheaper than blindly using <code>mlockall(…)</code> which will end-up locking all memory pages of the application (i.e. even those which are used only by non-RT threads).</p>
<p>The snippet below illustrates the usage of <code>mlockall(…)</code> :</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lock all current and future pages from preventing of being paged to swap */</span></span><br><span class="line"><span class="keyword">if</span> (mlockall( MCL_CURRENT | MCL_FUTURE )) &#123; </span><br><span class="line">        perror(<span class="string">"mlockall failed"</span>);</span><br><span class="line">        <span class="comment">/* exit(-1) or do error handling */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    Real-time applications should use memory-locking APIs early in their life, prior to performing real-time activities, so as to not incur page-faults in RT critical path. Failing to do so may significantly impact the determinism of the application.</p>
<p>​    Note that memory locking is required irrespective of whether <em>swap area</em> is configured for a system or not. This is because pages for read-only memory areas (like program code) could be dropped from the memory, when the system is facing memory pressure. Such read-only pages (being identical to on-disk copy), would be brought back straight from the disk (and not swap), resulting in page-faults even on setups without a swap-memory.</p>
<h4 id="Stack-Memory-for-RT-threads"><a href="#Stack-Memory-for-RT-threads" class="headerlink" title="Stack Memory for RT threads"></a>Stack Memory for RT threads</h4><p>​    All threads (RT and non-RT) within an application have their own private stack. It is recommended that an application should understand the <em>stack size</em> needs for its RT threads and set them explicitly before spawning them. This can be done via the <code>pthread_attr_setstacksize(…)</code> call as shown in the snippet below. If the size is not explicitly set, then the thread gets the default stack size (<code>pthread_attr_getstacksize()</code> can be used to find out how much this is, it was 8MB at the time of this writing).</p>
<p>​    Aforementioned <code>mlockall(…)</code> is sufficient to pin the entire thread stack in RAM, so that pagefaults are not incurred while the thread stack is being used. If the application spawns a large number of RT threads, it is advisable to specify a smaller stack size (than the default) in the interest of not exhausting memory.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create_rt_thread</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> thread;</span><br><span class="line">        <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* init to default values */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_attr_init(&amp;attr))</span><br><span class="line">  	         error(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* Set a specific stack size   */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_attr_setstacksize(&amp;attr, PTHREAD_STACK_MIN + MY_STACK_SIZE))</span><br><span class="line">  	        error(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">/* And finally start the actual thread */</span></span><br><span class="line">        pthread_create(&amp;thread, &amp;attr, rt_func, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    Details: The entire stack of every thread inside the application is forced to RAM when <code>mlockall(MCL_CURRENT)</code> is called. Threads created after a call to <code>mlockall(MCL_CURRENT | MCL_FUTURE)</code> will generate page faults immediately (on creation), as the new stack is immediately forced to RAM (due to the MCL_FUTURE flag). So all RT threads need to be created at startup time, before the RT show time. With <code>mlockall(…)</code> no explicit additional prefaulting necessary to avoid pagefaults during first (or subsequent) access.</p>
<h4 id="Dynamic-memory-allocation-in-RT-threads"><a href="#Dynamic-memory-allocation-in-RT-threads" class="headerlink" title="Dynamic memory allocation in RT threads"></a>Dynamic memory allocation in RT threads</h4><p>​    Real-time threads should avoid doing dynamic memory allocation / freeing while in RT critical path. The suggested recommendation for real-time threads, is to do the allocations, prior-to entering RT critical path. Subsequently RT threads, within their RT-critical path, can use this pre-allocated dynamic memory, provided that it is locked as described <a href="https://wiki.linuxfoundation.org/realtime/documentation/howto/applications/memory#memory-locking" target="_blank" rel="noopener">here</a>.</p>
<p>​    Non RT-threads within the applications have no restrictions on dynamic allocation / free.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*                                                                  </span></span><br><span class="line"><span class="comment"> * POSIX Real Time Example</span></span><br><span class="line"><span class="comment"> * using a single pthread as RT thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* Do RT specific stuff here */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line">        <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">        <span class="keyword">pthread_t</span> thread;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Lock memory */</span></span><br><span class="line">        <span class="keyword">if</span>(mlockall(MCL_CURRENT|MCL_FUTURE) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"mlockall failed: %m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Initialize pthread attributes (default values) */</span></span><br><span class="line">        ret = pthread_attr_init(&amp;attr);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"init pthread attributes failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Set a specific stack size  */</span></span><br><span class="line">        ret = pthread_attr_setstacksize(&amp;attr, PTHREAD_STACK_MIN);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"pthread setstacksize failed\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Set scheduler policy and priority of pthread */</span></span><br><span class="line">        ret = pthread_attr_setschedpolicy(&amp;attr, SCHED_FIFO);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pthread setschedpolicy failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        param.sched_priority = <span class="number">80</span>;</span><br><span class="line">        ret = pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pthread setschedparam failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Use scheduling parameters of attr */</span></span><br><span class="line">        ret = pthread_attr_setinheritsched(&amp;attr, PTHREAD_EXPLICIT_SCHED);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pthread setinheritsched failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Create a pthread with specified attributes */</span></span><br><span class="line">        ret = pthread_create(&amp;thread, &amp;attr, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"create pthread failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Join the thread and wait until it is done */</span></span><br><span class="line">        ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"join pthread failed: %m\n"</span>);</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Build-a-basic-cyclic-application"><a href="#Build-a-basic-cyclic-application" class="headerlink" title="Build a basic cyclic application"></a>Build a basic cyclic application</h2><h4 id="Cyclic-Task"><a href="#Cyclic-Task" class="headerlink" title="Cyclic Task"></a>Cyclic Task</h4><p>​    A cyclic task is one which is repeated after a fixed period of time like reading sensor data every 100 ms. The execution time for the cyclic task should always be less than the period of the task. Following are the mechanisms which we will be looking at for implementing cyclic task:</p>
<ul>
<li>nanosleep</li>
<li>EDF Scheduling</li>
</ul>
<h4 id="Current-Time"><a href="#Current-Time" class="headerlink" title="Current Time"></a>Current Time</h4><p>​    There are multiple ways to get current time – gettimeofday, time, clock_gettime, and some other processor specific implementations. Some of them, like gettimeofday, will get time from the system clock. The system clock can be modified by other processes. Which means that the clock can go back in time. clock_gettime with CLOCK_MONOTONIC clock can be used to avoid this problem. CLOCK_MONOTONIC argument ensures that we get a nonsettable monotonically increasing clock that measures time from some unspecified point in the past that does not change after system startup[1]. It is also important to ensure we do not waste a lot of CPU cycles to get the current time. CPU specific implementations to get the current time will be helpful here.</p>
<h4 id="Basic-Stub"><a href="#Basic-Stub" class="headerlink" title="Basic Stub"></a>Basic Stub</h4><p>Any mechanism for implementing a cyclic task can be divided into the following parts:</p>
<ul>
<li>periodic_task_init(): Initialization code for doing things like requesting timers, initializing variables, setting timer periods.</li>
<li>do_rt_task(): The real time task is done here.</li>
<li>wait_rest_of_period(): After the task is done, wait for the rest of the period. The assumption here is the task requires less time to complete compared to the period length.</li>
<li>struct period_info: This is a struct which will be used to pass around data required by the above mentioned functions.</li>
</ul>
<p>The stub for the real time task will look like:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">simple_cyclic_task</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">period_info</span> <span class="title">pinfo</span>;</span></span><br><span class="line"> </span><br><span class="line">        periodic_task_init(&amp;pinfo);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                do_rt_task();</span><br><span class="line">                wait_rest_of_period(&amp;pinfo);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><p><strong>clock_nanosleep</strong></p>
<p>clock_nanosleep() is used to ask the process to sleep for certain amount of time. nanosleep() can also be used to sleep. But, nanosleep() uses CLOCK_REALTIME which can be changed by another processes and hence can be discontinuous or jump back in time. In clock_nanosleep, CLOCK_MONOTONIC is explicitly specified. This is a immutable clock which does not change after startup. The periodicity is achieved by using absolute time to specify the end of each period. More information on clock_nanosleep at <a href="http://man7.org/linux/man-pages/man2/clock_nanosleep.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/clock_nanosleep.2.html</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">period_info</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">next_period</span>;</span></span><br><span class="line">        <span class="keyword">long</span> period_ns;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc_period</span><span class="params">(struct period_info *pinfo)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pinfo-&gt;next_period.tv_nsec += pinfo-&gt;period_ns;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (pinfo-&gt;next_period.tv_nsec &gt;= <span class="number">1000000000</span>) &#123;</span><br><span class="line">                <span class="comment">/* timespec nsec overflow */</span></span><br><span class="line">                pinfo-&gt;next_period.tv_sec++;</span><br><span class="line">                pinfo-&gt;next_period.tv_nsec -= <span class="number">1000000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">periodic_task_init</span><span class="params">(struct period_info *pinfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* for simplicity, hardcoding a 1ms period */</span></span><br><span class="line">        pinfo-&gt;period_ns = <span class="number">1000000</span>;</span><br><span class="line"> </span><br><span class="line">        clock_gettime(CLOCK_MONOTONIC, &amp;(pinfo-&gt;next_period));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_rt_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* Do RT stuff here. */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wait_rest_of_period</span><span class="params">(struct period_info *pinfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        inc_period(pinfo);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* for simplicity, ignoring possibilities of signal wakes */</span></span><br><span class="line">        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;pinfo-&gt;next_period, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EDF-Scheduler"><a href="#EDF-Scheduler" class="headerlink" title="EDF Scheduler"></a>EDF Scheduler</h4><p>​    Recently, earliest deadline first scheduling algorithm has been merged in the mainline kernel. Now, users can specify runtime, period and deadline of a task and they scheduler will run the task every specified period and will make sure the deadline is met. The scheduler will also let user know if the tasks(or a set of tasks) cannot be scheduled because the deadline won’t be met.</p>
<p>​    More information about the EDF scheduler including an example of implementation can be found at: <a href="https://www.kernel.org/doc/Documentation/scheduler/sched-deadline.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/scheduler/sched-deadline.txt</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By John Doe</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>