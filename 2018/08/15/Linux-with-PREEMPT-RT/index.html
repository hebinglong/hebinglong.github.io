<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Linux with PREEMPT_RT"><meta name="keywords" content="Linux"><meta name="author" content="hebinglong"><meta name="copyright" content="hebinglong"><title>Linux with PREEMPT_RT | DragonHo's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-with-PREEMPT-RT"><span class="toc-number">1.</span> <span class="toc-text">Linux with PREEMPT_RT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#博主总结"><span class="toc-number">1.1.</span> <span class="toc-text">博主总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setup-Linux-with-PREEMPT-RT-properly"><span class="toc-number">1.2.</span> <span class="toc-text">setup Linux with PREEMPT_RT properly</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Getting-the-sources"><span class="toc-number">1.2.1.</span> <span class="toc-text">Getting the sources</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Configuring-the-kernel"><span class="toc-number">1.2.2.</span> <span class="toc-text">Configuring the kernel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Building-the-kernel"><span class="toc-number">1.2.3.</span> <span class="toc-text">Building the kernel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Build-a-simple-RT-application"><span class="toc-number">1.3.</span> <span class="toc-text">Build a simple RT application</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Basic-prerequisites"><span class="toc-number">1.3.1.</span> <span class="toc-text">Basic prerequisites</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scheduling-and-priority"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Scheduling and priority</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-for-Real-time-Applications"><span class="toc-number">1.3.2.</span> <span class="toc-text">Memory for Real-time Applications</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-Locking"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">Memory Locking</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stack-Memory-for-RT-threads"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">Stack Memory for RT threads</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dynamic-memory-allocation-in-RT-threads"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">Dynamic memory allocation in RT threads</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example"><span class="toc-number">1.3.3.</span> <span class="toc-text">Example</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Build-a-basic-cyclic-application"><span class="toc-number">1.4.</span> <span class="toc-text">Build a basic cyclic application</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cyclic-Task"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">Cyclic Task</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Current-Time"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">Current Time</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Basic-Stub"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">Basic Stub</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Examples"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">Examples</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EDF-Scheduler"><span class="toc-number">1.4.0.5.</span> <span class="toc-text">EDF Scheduler</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">hebinglong</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">12</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">DragonHo's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Linux with PREEMPT_RT</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-08-15</time></div><div class="article-container" id="post-content"><h1 id="Linux-with-PREEMPT-RT"><a href="#Linux-with-PREEMPT-RT" class="headerlink" title="Linux with PREEMPT_RT"></a>Linux with PREEMPT_RT</h1><h2 id="博主总结"><a href="#博主总结" class="headerlink" title="博主总结"></a>博主总结</h2><p>文章摘录自 <a href="https://wiki.linuxfoundation.org/realtime/documentation/start" target="_blank" rel="noopener">https://wiki.linuxfoundation.org/realtime/documentation/start</a> 更多内容请前往该网址查看</p>
<p>本博文介绍了如何在标准的Linux系统上<strong>打 PREEMPT_RT 补丁</strong>使之具备实时性，其实就是教你怎么编译内核。</p>
<p>除了介绍如何打补丁外，讲述了如何建立一个基础的<strong>实时线程</strong>，并介绍了实时线程在内存方面的注意事项，包括</p>
<ol>
<li><p>锁内存</p>
</li>
<li><p>栈内存</p>
</li>
<li><p>动态内存分配</p>
<p>​</p>
<p>最后给出了在实时线程的基础上给出了<strong>周期任务在实时线程中的实现方式</strong>例子。</p>
</li>
</ol>
<h2 id="setup-Linux-with-PREEMPT-RT-properly"><a href="#setup-Linux-with-PREEMPT-RT-properly" class="headerlink" title="setup Linux with PREEMPT_RT properly"></a>setup Linux with PREEMPT_RT properly</h2><p>​    Linux in itself is not real time capable. With the additional PREEMPT_RT patch it gains real-time capabilities. The sources have to be downloaded first. After unpacking and patching, the kernel configuration has to be adapted. Then, the kernel can be built and started.</p>
<h3 id="Getting-the-sources"><a href="#Getting-the-sources" class="headerlink" title="Getting the sources"></a>Getting the sources</h3><p>​    First, the kernel version should be chosen. After this, take a look if the PREEMPT_RT patch is <a href="https://www.kernel.org/pub/linux/kernel/projects/rt" target="_blank" rel="noopener">available</a> for this particular version.</p>
<p>​    The source of the desired version has to be downloaded (for the Linux kernel as well as for the PREEMPT_RT patch). This example is based on the Linux kernel version 4.4.12.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.4.12.tar.xz</span><br><span class="line">$ wget https://www.kernel.org/pub/linux/kernel/projects/rt/4.4/patch-4.4.12-rt19.patch.xz</span><br></pre></td></tr></table></figure>
<p>After downloading, unpack the archives and patch the Linux kernel:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ xz -<span class="built_in">cd</span> linux-4.4.12.tar.xz | tar xvf -</span><br><span class="line">$ <span class="built_in">cd</span> linux-4.4.12</span><br><span class="line">$ xzcat ../patch-4.4.12-rt19.patch.xz | patch -p1</span><br></pre></td></tr></table></figure>
<h3 id="Configuring-the-kernel"><a href="#Configuring-the-kernel" class="headerlink" title="Configuring the kernel"></a>Configuring the kernel</h3><p>The only necessary configuration for real-time Linux kernel is the choice of the “Fully Preemptible Kernel” preemption model (CONFIG_PREEMPT_RT_FULL). All other kernel configuration parameters depend on system requirements. For detailed information about how to configure a kernel have a look at <a href="https://www.kernel.org/doc/Documentation/kbuild/kconfig.txt" target="_blank" rel="noopener">Linux kernel documentation</a>.</p>
<p>​    When measuring system latency all kernel debug options should be turned off. They require much overhead and distort the measurement result. Examples for those debug mechanism are:</p>
<ul>
<li><p>DEBUG_PREEMPT</p>
</li>
<li><p>Lock Debugging (spinlocks, mutexes, etc. . . )</p>
</li>
<li><p>DEBUG_OBJECTS</p>
</li>
<li><p>…</p>
<p>Some of those debugging mechanisms (like lock debugging) produce a randomized overhead in a range of some micro seconds to several milliseconds depending on the kernel configuration as well as on the compile options (DEBUG_PREEMPT has a low overhead compared to Lock Debugging or DEBUG_OBJECTS).</p>
<p>However, in the first run of a real-time capable Linux kernel it might be advisable to use those debugging mechanisms. This helps to locate fundamental problems.</p>
</li>
</ul>
<h3 id="Building-the-kernel"><a href="#Building-the-kernel" class="headerlink" title="Building the kernel"></a>Building the kernel</h3><p>​    Building the kernel and starting the kernel works similarly to a kernel without PREEMPT_RT patch.</p>
<h2 id="Build-a-simple-RT-application"><a href="#Build-a-simple-RT-application" class="headerlink" title="Build a simple RT application"></a>Build a simple RT application</h2><p>​    The POSIX API forms the basis of real-time applications running under PREEMPT_RT. For the real-time thread a POSIX thread is used (pthread). Every real-time application needs proper handling in several basic areas like scheduling, priority, memory locking and stack prefaulting.</p>
<h3 id="Basic-prerequisites"><a href="#Basic-prerequisites" class="headerlink" title="Basic prerequisites"></a>Basic prerequisites</h3><p>​    Three basic prerequisites are introduced in the next subsections, followed by a short example illustrating those aspects.</p>
<h4 id="Scheduling-and-priority"><a href="#Scheduling-and-priority" class="headerlink" title="Scheduling and priority"></a>Scheduling and priority</h4><p>​    The <a href="https://wiki.linuxfoundation.org/realtime/documentation/technical_basics/sched_policy_prio/start" target="_blank" rel="noopener">scheduling policy</a> as well as the priority must be set by the application explicitly. There are two possibilities for this:</p>
<ol>
<li><p><strong>Using sched_setscheduler()</strong></p>
<p>This funcion needs to be called in the start routine of the pthread before calculating RT specific stuff.</p>
</li>
<li><p><strong>Using pthread attributes</strong> </p>
<p>The functions <code>pthread_attr_setschedpolicy()</code> and <code>pthread_attr_setschedparam()</code>offer the interfaces to set policy and priority. Furthermore scheduler inheritance needs to be set properly to PTHREAD_EXPLICIT_SCHED by using <code>pthread_attr_setinheritsched()</code>. This forces the new thread to use the policy and priority specified by the pthread attributes and not to use the inherit scheduling of the thread which created the real-time thread.</p>
</li>
</ol>
<h3 id="Memory-for-Real-time-Applications"><a href="#Memory-for-Real-time-Applications" class="headerlink" title="Memory for Real-time Applications"></a>Memory for Real-time Applications</h3><p>​    Proper handling of memory will improve a real-time application’s deterministic behavior. Three areas of memory management within the purview of a real-time application are considered :</p>
<ol>
<li><strong>Memory Locking</strong></li>
<li><strong>Stack Memory for RT threads</strong></li>
<li><strong>Dynamic memory allocation</strong></li>
</ol>
<p>Keep in mind that the <a href="https://wiki.linuxfoundation.org/realtime/documentation/howto/applications/application_base" target="_blank" rel="noopener">usual sequence</a> is for an application to begin its execution as a regular (non-RT) application, then create the RT threads with appropriate resources and scheduling parameters.</p>
<h4 id="Memory-Locking"><a href="#Memory-Locking" class="headerlink" title="Memory Locking"></a>Memory Locking</h4><p>Memory locking APIs allow an application to instruct the kernel to associate (some or all of its) virtual memory pages with real page frames and keep it that way. In other words :</p>
<ul>
<li><p>Memory locking APIs will trigger the necessary page-faults, to bring in the pages being locked, to physical memory. Consequently first access to a locked-memory (following an <code>mlock*()</code> call) will already have physical memory assigned and will not page fault (in RT-critical path). This removes the need to explicitly pre-fault these memory.</p>
</li>
<li><p>Further memory locking prevents an application’s memory pages, from being paged-out, anytime during its lifetime even in when the overall system is facing memory pressure.</p>
</li>
</ul>
<p>Applications can either use <code>mlock(…)</code> or <code>mlockall(…)</code> for memory locking. Specifics of these C Library calls can be found here <a href="http://www.gnu.org/software/libc/manual/html_node/Locking-Pages.html" target="_blank" rel="noopener">The GNU C Library: Locking pages</a>. Note that these calls requires the application to have sufficient privileges (i.e. <a href="http://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">CAP_IPC_LOCK capability</a>) to succeed.</p>
<p>While <code>mlock(&lt;addr&gt;, &lt;length&gt;)</code> locks specific pages (described by <em>address</em> and <em>length</em>), <code>mlockall(…)</code> locks an application’s entire virtual address space (i.e <a href="https://wiki.linuxfoundation.org/realtime/documentation/howto/applications/memory/mlockall_globals_sample" target="_blank" rel="noopener">globals</a>, stack, heap, code) in physical memory. The trade-off between convenience and locking-up excess RAM should drive the choice of one over the other. Locking only those areas which are accessed by RT-threads (using <code>mlock(…)</code>) could be cheaper than blindly using <code>mlockall(…)</code> which will end-up locking all memory pages of the application (i.e. even those which are used only by non-RT threads).</p>
<p>The snippet below illustrates the usage of <code>mlockall(…)</code> :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Lock all current and future pages from preventing of being paged to swap */</span></span><br><span class="line"><span class="keyword">if</span> (mlockall( MCL_CURRENT | MCL_FUTURE )) &#123; </span><br><span class="line">        perror(<span class="string">"mlockall failed"</span>);</span><br><span class="line">        <span class="comment">/* exit(-1) or do error handling */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    Real-time applications should use memory-locking APIs early in their life, prior to performing real-time activities, so as to not incur page-faults in RT critical path. Failing to do so may significantly impact the determinism of the application.</p>
<p>​    Note that memory locking is required irrespective of whether <em>swap area</em> is configured for a system or not. This is because pages for read-only memory areas (like program code) could be dropped from the memory, when the system is facing memory pressure. Such read-only pages (being identical to on-disk copy), would be brought back straight from the disk (and not swap), resulting in page-faults even on setups without a swap-memory.</p>
<h4 id="Stack-Memory-for-RT-threads"><a href="#Stack-Memory-for-RT-threads" class="headerlink" title="Stack Memory for RT threads"></a>Stack Memory for RT threads</h4><p>​    All threads (RT and non-RT) within an application have their own private stack. It is recommended that an application should understand the <em>stack size</em> needs for its RT threads and set them explicitly before spawning them. This can be done via the <code>pthread_attr_setstacksize(…)</code> call as shown in the snippet below. If the size is not explicitly set, then the thread gets the default stack size (<code>pthread_attr_getstacksize()</code> can be used to find out how much this is, it was 8MB at the time of this writing).</p>
<p>​    Aforementioned <code>mlockall(…)</code> is sufficient to pin the entire thread stack in RAM, so that pagefaults are not incurred while the thread stack is being used. If the application spawns a large number of RT threads, it is advisable to specify a smaller stack size (than the default) in the interest of not exhausting memory.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create_rt_thread</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> thread;</span><br><span class="line">        <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* init to default values */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_attr_init(&amp;attr))</span><br><span class="line">  	         error(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* Set a specific stack size   */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_attr_setstacksize(&amp;attr, PTHREAD_STACK_MIN + MY_STACK_SIZE))</span><br><span class="line">  	        error(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">/* And finally start the actual thread */</span></span><br><span class="line">        pthread_create(&amp;thread, &amp;attr, rt_func, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    Details: The entire stack of every thread inside the application is forced to RAM when <code>mlockall(MCL_CURRENT)</code> is called. Threads created after a call to <code>mlockall(MCL_CURRENT | MCL_FUTURE)</code> will generate page faults immediately (on creation), as the new stack is immediately forced to RAM (due to the MCL_FUTURE flag). So all RT threads need to be created at startup time, before the RT show time. With <code>mlockall(…)</code> no explicit additional prefaulting necessary to avoid pagefaults during first (or subsequent) access.</p>
<h4 id="Dynamic-memory-allocation-in-RT-threads"><a href="#Dynamic-memory-allocation-in-RT-threads" class="headerlink" title="Dynamic memory allocation in RT threads"></a>Dynamic memory allocation in RT threads</h4><p>​    Real-time threads should avoid doing dynamic memory allocation / freeing while in RT critical path. The suggested recommendation for real-time threads, is to do the allocations, prior-to entering RT critical path. Subsequently RT threads, within their RT-critical path, can use this pre-allocated dynamic memory, provided that it is locked as described <a href="https://wiki.linuxfoundation.org/realtime/documentation/howto/applications/memory#memory-locking" target="_blank" rel="noopener">here</a>.</p>
<p>​    Non RT-threads within the applications have no restrictions on dynamic allocation / free.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*                                                                  </span></span><br><span class="line"><span class="comment"> * POSIX Real Time Example</span></span><br><span class="line"><span class="comment"> * using a single pthread as RT thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* Do RT specific stuff here */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line">        <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">        <span class="keyword">pthread_t</span> thread;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Lock memory */</span></span><br><span class="line">        <span class="keyword">if</span>(mlockall(MCL_CURRENT|MCL_FUTURE) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"mlockall failed: %m\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Initialize pthread attributes (default values) */</span></span><br><span class="line">        ret = pthread_attr_init(&amp;attr);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"init pthread attributes failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Set a specific stack size  */</span></span><br><span class="line">        ret = pthread_attr_setstacksize(&amp;attr, PTHREAD_STACK_MIN);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"pthread setstacksize failed\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Set scheduler policy and priority of pthread */</span></span><br><span class="line">        ret = pthread_attr_setschedpolicy(&amp;attr, SCHED_FIFO);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pthread setschedpolicy failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        param.sched_priority = <span class="number">80</span>;</span><br><span class="line">        ret = pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pthread setschedparam failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Use scheduling parameters of attr */</span></span><br><span class="line">        ret = pthread_attr_setinheritsched(&amp;attr, PTHREAD_EXPLICIT_SCHED);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"pthread setinheritsched failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Create a pthread with specified attributes */</span></span><br><span class="line">        ret = pthread_create(&amp;thread, &amp;attr, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"create pthread failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Join the thread and wait until it is done */</span></span><br><span class="line">        ret = pthread_join(thread, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"join pthread failed: %m\n"</span>);</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Build-a-basic-cyclic-application"><a href="#Build-a-basic-cyclic-application" class="headerlink" title="Build a basic cyclic application"></a>Build a basic cyclic application</h2><h4 id="Cyclic-Task"><a href="#Cyclic-Task" class="headerlink" title="Cyclic Task"></a>Cyclic Task</h4><p>​    A cyclic task is one which is repeated after a fixed period of time like reading sensor data every 100 ms. The execution time for the cyclic task should always be less than the period of the task. Following are the mechanisms which we will be looking at for implementing cyclic task:</p>
<ul>
<li>nanosleep</li>
<li>EDF Scheduling</li>
</ul>
<h4 id="Current-Time"><a href="#Current-Time" class="headerlink" title="Current Time"></a>Current Time</h4><p>​    There are multiple ways to get current time – gettimeofday, time, clock_gettime, and some other processor specific implementations. Some of them, like gettimeofday, will get time from the system clock. The system clock can be modified by other processes. Which means that the clock can go back in time. clock_gettime with CLOCK_MONOTONIC clock can be used to avoid this problem. CLOCK_MONOTONIC argument ensures that we get a nonsettable monotonically increasing clock that measures time from some unspecified point in the past that does not change after system startup[1]. It is also important to ensure we do not waste a lot of CPU cycles to get the current time. CPU specific implementations to get the current time will be helpful here.</p>
<h4 id="Basic-Stub"><a href="#Basic-Stub" class="headerlink" title="Basic Stub"></a>Basic Stub</h4><p>Any mechanism for implementing a cyclic task can be divided into the following parts:</p>
<ul>
<li>periodic_task_init(): Initialization code for doing things like requesting timers, initializing variables, setting timer periods.</li>
<li>do_rt_task(): The real time task is done here.</li>
<li>wait_rest_of_period(): After the task is done, wait for the rest of the period. The assumption here is the task requires less time to complete compared to the period length.</li>
<li>struct period_info: This is a struct which will be used to pass around data required by the above mentioned functions.</li>
</ul>
<p>The stub for the real time task will look like:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">simple_cyclic_task</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">period_info</span> <span class="title">pinfo</span>;</span></span><br><span class="line"> </span><br><span class="line">        periodic_task_init(&amp;pinfo);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                do_rt_task();</span><br><span class="line">                wait_rest_of_period(&amp;pinfo);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><p><strong>clock_nanosleep</strong></p>
<p>clock_nanosleep() is used to ask the process to sleep for certain amount of time. nanosleep() can also be used to sleep. But, nanosleep() uses CLOCK_REALTIME which can be changed by another processes and hence can be discontinuous or jump back in time. In clock_nanosleep, CLOCK_MONOTONIC is explicitly specified. This is a immutable clock which does not change after startup. The periodicity is achieved by using absolute time to specify the end of each period. More information on clock_nanosleep at <a href="http://man7.org/linux/man-pages/man2/clock_nanosleep.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/clock_nanosleep.2.html</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">period_info</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">next_period</span>;</span></span><br><span class="line">        <span class="keyword">long</span> period_ns;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc_period</span><span class="params">(struct period_info *pinfo)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        pinfo-&gt;next_period.tv_nsec += pinfo-&gt;period_ns;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (pinfo-&gt;next_period.tv_nsec &gt;= <span class="number">1000000000</span>) &#123;</span><br><span class="line">                <span class="comment">/* timespec nsec overflow */</span></span><br><span class="line">                pinfo-&gt;next_period.tv_sec++;</span><br><span class="line">                pinfo-&gt;next_period.tv_nsec -= <span class="number">1000000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">periodic_task_init</span><span class="params">(struct period_info *pinfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* for simplicity, hardcoding a 1ms period */</span></span><br><span class="line">        pinfo-&gt;period_ns = <span class="number">1000000</span>;</span><br><span class="line"> </span><br><span class="line">        clock_gettime(CLOCK_MONOTONIC, &amp;(pinfo-&gt;next_period));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_rt_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* Do RT stuff here. */</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wait_rest_of_period</span><span class="params">(struct period_info *pinfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        inc_period(pinfo);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* for simplicity, ignoring possibilities of signal wakes */</span></span><br><span class="line">        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;pinfo-&gt;next_period, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EDF-Scheduler"><a href="#EDF-Scheduler" class="headerlink" title="EDF Scheduler"></a>EDF Scheduler</h4><p>​    Recently, earliest deadline first scheduling algorithm has been merged in the mainline kernel. Now, users can specify runtime, period and deadline of a task and they scheduler will run the task every specified period and will make sure the deadline is met. The scheduler will also let user know if the tasks(or a set of tasks) cannot be scheduled because the deadline won’t be met.</p>
<p>​    More information about the EDF scheduler including an example of implementation can be found at: <a href="https://www.kernel.org/doc/Documentation/scheduler/sched-deadline.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/scheduler/sched-deadline.txt</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">hebinglong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/08/15/Linux-with-PREEMPT-RT/">http://yoursite.com/2018/08/15/Linux-with-PREEMPT-RT/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/08/15/Linux操作系统实时性分析/"><i class="fa fa-chevron-left">  </i><span>Linux操操作系统实时性分析</span></a></div><div class="next-post pull-right"><a href="/2018/08/14/ROS学习总结1-系统架构/"><span>ROS学习总结1:系统架构</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By hebinglong</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>